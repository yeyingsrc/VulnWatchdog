## CVE-2025-39964-Linux Kernel-af_alg并发写漏洞

**漏洞编号:** CVE-2025-39964

**漏洞类型:** 并发写漏洞

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致拒绝服务或代码执行

**影响版本:** Linux kernel 2.6.38 直到但不包含 5.10.245, 5.15.194, 6.1.154, 6.6.108, 6.12.49, 6.16.9, 6.17

**利用条件:** 需要具有创建和操作AF_ALG套接字权限

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-39964 描述的是 Linux 内核中 af_alg (Algorithm Framework) 子系统存在的并发写漏洞。该漏洞位于 `crypto/af_alg.c` 文件中的 `af_alg_sendmsg` 函数，在修复前允许同时向同一个 af_alg 套接字写入数据。由于数据会以不可预测的方式交错，可能导致内部套接字状态不一致，最终导致拒绝服务或代码执行。

**漏洞利用方式:**

1.  **AF_ALG 套接字创建:** 利用代码首先创建多个 AF_UNIX socketpair。每个socketpair都会被用于后续的并发写操作。
2.  **并发写触发:**  利用代码使用多个线程并发地向同一个 af_alg 套接字写入数据。通过 `sendmsg` 系统调用发送消息，并配合 `pthread_create` 创建多个线程，同时写入数据来触发漏洞。
3.  **内存布局控制（spray）:** 为了增加漏洞利用的成功率，利用代码通过 `setsockopt` 调整缓冲区大小，并使用 `sendmsg` 和带有 `cmsghdr` 的消息进行内存喷射，尝试将精心构造的数据放置在特定的内存地址。
4. **KASLR绕过:** 利用代码尝试绕过地址空间布局随机化（KASLR）。存在两种方式：一种是通过硬编码的地址，另一种是通过读取`/proc/kallsyms`来获取内核代码段的基址。虽然这种读取方式需要sudo权限，但这也可能是为了方便本地测试。
5.  **提权:** 利用代码通过覆写`/proc/sys/kernel/core_pattern`文件实现提权，`/proc/sys/kernel/core_pattern` 指示当程序崩溃时，内核应该执行哪个程序来处理 core dump。PoC中，`core_pattern`被设置为指向`/proc/%P/fd/666`，其中%P是崩溃进程的PID, fd/666是PoC进程打开的特定文件描述符.崩溃进程将通过execve执行fd/666指向的程序。攻击者可利用此机制执行恶意代码。
6.  **触发崩溃:** 利用代码的最后一步是通过访问空指针 `*(size_t *)0 = 0;` 触发内核崩溃。此时，由于 `core_pattern` 已经被篡改，内核会执行攻击者指定的代码，从而实现提权。

**有效性:**

该 PoC 代码针对的是 af_alg 并发写漏洞，目标是利用并发写操作破坏内核数据结构，最终通过覆写core_pattern实现提权。代码比较完整，具备漏洞利用的潜力。需要注意的是，代码中包含KASLR绕过，可能需要根据目标环境进行调整。

**投毒风险:**

在分析提供的 PoC 代码后，没有发现明显的投毒代码。尽管代码的功能是提权，这本身不是后门，而是漏洞利用的最终目的。代码中存在与提权无关的恶意或隐藏功能，没有发现，因此投毒风险为0%。

**项目地址:** [n1k0oowang/CVE-2025-39964_EXP](https://github.com/n1k0oowang/CVE-2025-39964_EXP)

**漏洞详情:** [CVE-2025-39964](https://nvd.nist.gov/vuln/detail/CVE-2025-39964)